<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>LLM 模型显存计算器</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }
        th, td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }
        th {
            background-color: #f8f9fa;
        }
        tr:hover {
            background-color: #f8f9fa;
        }
        .memory-info {
            margin-top: 20px;
            padding: 15px;
            background-color: #e9ecef;
            border-radius: 4px;
        }
        .highlight {
            background-color: #e2f3ff !important;
        }
        #gpuMemory {
            padding: 8px;
            margin-right: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        button {
            padding: 8px 15px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        button:hover {
            background-color: #0056b3;
        }
        .warning {
            color: #dc3545;
        }
        .success {
            color: #28a745;
        }
        .control-panel {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        .control-panel div {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .control-panel label {
            font-weight: bold;
        }
        .control-panel select,
        .control-panel input {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }
        .control-panel input[type="number"] {
            width: 100%;
        }
        /* 添加链接样式 */
        .model-link {
            color: #007bff;
            text-decoration: none;
            cursor: pointer;
        }
        
        .model-link:hover {
            text-decoration: underline;
            color: #0056b3;
        }
        
        #modelDescription {
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 4px;
            line-height: 1.6;
            margin-bottom: 20px;
        }
        
        .memory-info {
            margin: 20px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>LLM 模型显存计算器</h1>
        
        <div class="control-panel">
            <div>
                <label for="modelType">选择模型系列:</label>
                <select id="modelType" onchange="loadModelData()">
                    <!-- 将由 JavaScript 填充 -->
                </select>
            </div>
            <div>
                <label for="gpuMemory">GPU显存大小 (GB):</label>
                <input type="number" id="gpuMemory" min="1" step="1" oninput="updateGpuMemory(this.value)">
            </div>
            <div>
                <label for="quantization">量化方式:</label>
                <select id="quantization" onchange="calculateCompatibility()">
                    <option value="Q4_K_M">4-bit 量化 (最小内存)</option>
                    <option value="Q8_0">8-bit 量化 (平衡)</option>
                    <option value="FP16">16-bit 精度 (最高质量)</option>
                </select>
            </div>
        </div>

        <div class="memory-info">
            <p>模型描述：</p>
            <div id="modelDescription">
                <!-- 将由 JavaScript 填充 -->
            </div>
        </div>

        <table id="modelTable">
            <thead>
                <tr>
                    <th>模型</th>
                    <th>大小标签</th>
                    <th>文件大小</th>
                    <th>量化方式</th>
                    <th>预估显存需求</th>
                    <th>状态</th>
                </tr>
            </thead>
            <tbody id="modelTableBody">
                <!-- 将由 JavaScript 填充 -->
            </tbody>
        </table>

        <div class="memory-info" style="margin-top: 20px; font-style: italic; color: #666;">
            <p>注意：实际显存使用可能因具体环境而异，建议预留20%余量</p>
        </div>
    </div>

    <script>
        // 量化方式显示名称映射
        const QUANT_DISPLAY_NAMES = {
            'BASE': '基础版本 (无量化)',
            'FP16': 'Float16 精度 (16位浮点)',
            'Q8_0': '8-bit 量化 (INT8)',
            'Q6_K': '6-bit 量化 (INT6)',
            'Q5_K_M': '5-bit 量化 (INT5)',
            'Q4_K_M': '4-bit 量化 (INT4)',
            'Q3_K_M': '3-bit 量化 (INT3)',
            'Q2_K': '2-bit 量化 (INT2)'
        };

        // 量化方式的详细描述
        const QUANT_DESCRIPTIONS = {
            'BASE': '原始模型，无量化压缩，需要最大显存',
            'FP16': '16位浮点精度，保持较高精度，适合专业显卡',
            'Q8_0': '8位量化，平衡性能与质量',
            'Q6_K': '6位量化，较好的压缩比与性能平衡',
            'Q5_K_M': '5位量化，更高压缩比',
            'Q4_K_M': '4位量化，高压缩比，适合消费级显卡',
            'Q3_K_M': '3位量化，超高压缩比',
            'Q2_K': '2位量化，最大压缩比，可能影响性能'
        };

        // 更新量化选择下拉框
        function updateQuantizationOptions() {
            if (!window.currentModelData) return;
            
            // 获取当前模型所有可用的量化方式
            const availableQuants = [...new Set(window.currentModelData.map(model => model.quantization))];
            availableQuants.sort((a, b) => {
                // 自定义排序顺序：BASE > FP16 > Q8_0 > Q6_K > Q5_K_M > Q4_K_M > Q3_K_M > Q2_K
                const order = {
                    'BASE': 0,
                    'FP16': 1,
                    'Q8_0': 2,
                    'Q6_K': 3,
                    'Q5_K_M': 4,
                    'Q4_K_M': 5,
                    'Q3_K_M': 6,
                    'Q2_K': 7
                };
                return order[a] - order[b];
            });

            const select = document.getElementById('quantization');
            const currentValue = select.value;
            
            // 生成新的选项
            select.innerHTML = availableQuants.map(quant => 
                `<option value="${quant}" 
                         title="${QUANT_DESCRIPTIONS[quant] || ''}"
                         ${currentValue === quant ? 'selected' : ''}>
                    ${QUANT_DISPLAY_NAMES[quant] || quant}
                </option>`
            ).join('');

            // 如果当前没有选中的量化方式
            if (!currentValue || !availableQuants.includes(currentValue)) {
                // 检查是否有4bit量化选项
                const has4bit = availableQuants.some(quant => quant === 'Q4_K_M');
                if (has4bit) {
                    // 如果有4bit量化，选择它
                    select.value = 'Q4_K_M';
                } else {
                    // 如果没有4bit量化，选择第一个可用的量化方式
                    select.value = availableQuants[0];
                }
            }
        }

        // 加载配置文件
        async function loadConfig() {
            try {
                const response = await fetch('config.json');
                return await response.json();
            } catch (error) {
                console.error('加载配置文件失败:', error);
                return null;
            }
        }

        // 初始化模型选择下拉列表
        async function initializeModelSelect() {
            const config = await loadConfig();
            if (!config) return;

            const select = document.getElementById('modelType');
            select.innerHTML = config.models.map(model => 
                `<option value="${model.output_file}">${model.name}</option>`
            ).join('');

            // 加载第一个模型的数据
            loadModelData();
        }

        // 加载选中模型的数据和描述
        async function loadModelData() {
            const select = document.getElementById('modelType');
            const selectedOption = select.selectedOptions[0];
            const modelFile = selectedOption.value;
            
            try {
                // 加载配置文件获取描述
                const config = await loadConfig();
                const selectedModel = config.models.find(model => model.output_file === modelFile);
                
                // 更新模型描述
                if (selectedModel) {
                    document.getElementById('modelDescription').textContent = selectedModel.description;
                }
                
                // 加载模型数据
                const response = await fetch(`modeldata/cleaned/${modelFile}`);
                const data = await response.json();
                window.currentModelData = data;
                
                // 更新量化选项后再计算兼容性
                updateQuantizationOptions();
                calculateCompatibility();
            } catch (error) {
                console.error('加载模型数据失败:', error);
            }
        }

        // 计算显存需求
        function calculateMemoryRequirement(fileSize, quantization) {
            const sizeMatch = fileSize.match(/(\d+\.?\d*)\s*(GB|TB)/i);
            if (!sizeMatch) return 0.5; // 最小返回0.5GB
            
            let size = parseFloat(sizeMatch[1]);
            if (sizeMatch[2].toUpperCase() === 'TB') {
                size *= 1024;
            }

            let memoryRequired;
            switch (quantization.toUpperCase()) {
                case 'FP16':
                    memoryRequired = size * 2;
                    break;
                case 'Q8_0':
                    memoryRequired = size * 1.5;
                    break;
                case 'Q4_K_M':
                    memoryRequired = size * 1.2;
                    break;
                default:
                    memoryRequired = size * 1.2;
            }
            
            // 设置最小显存需求为0.5GB
            return Math.max(memoryRequired, 0.5);
        }

        // 计算兼容性并更新表格
        function calculateCompatibility() {
            if (!window.currentModelData) {
                console.error('没有可用的模型数据');
                return;
            }

            const gpuMemory = parseFloat(document.getElementById('gpuMemory').value);
            const selectedQuant = document.getElementById('quantization').value;
            const tbody = document.getElementById('modelTableBody');
            tbody.innerHTML = '';

            // 过滤选中量化方式的模型
            const filteredModels = window.currentModelData.filter(model => 
                model.quantization.toUpperCase() === selectedQuant.toUpperCase()
            );

            filteredModels.forEach(model => {
                const memoryRequired = calculateMemoryRequirement(model.file_size, model.quantization);
                const isCompatible = memoryRequired <= gpuMemory;

                const row = tbody.insertRow();
                row.innerHTML = `
                    <td>
                        <a href="${model.url}" 
                           class="model-link" 
                           target="_blank" 
                           title="点击查看模型详情">
                            ${model.model}
                        </a>
                    </td>
                    <td>${model.size_label}</td>
                    <td>${model.file_size}</td>
                    <td>${QUANT_DISPLAY_NAMES[model.quantization] || model.quantization}</td>
                    <td>${memoryRequired.toFixed(1)} GB</td>
                    <td class="${isCompatible ? 'success' : 'warning'}">
                        ${isCompatible ? '✓ 可运行' : '✗ 显存不足'}
                    </td>
                `;

                if (isCompatible) {
                    row.classList.add('highlight');
                }
            });
        }

        // 从本地存储加载GPU显存设置
        function loadGpuMemorySettings() {
            const savedMemory = localStorage.getItem('gpuMemory');
            const gpuMemoryInput = document.getElementById('gpuMemory');
            if (savedMemory) {
                gpuMemoryInput.value = savedMemory;
            } else {
                // 默认值设为24
                gpuMemoryInput.value = 24;
                localStorage.setItem('gpuMemory', '24');
            }
        }

        // 更新GPU显存设置
        function updateGpuMemory(value) {
            localStorage.setItem('gpuMemory', value);
            calculateCompatibility();
        }

        // 初始化页面
        async function initializePage() {
            // 加载GPU显存设置
            loadGpuMemorySettings();
            // 初始化模型选择
            await initializeModelSelect();
        }

        // 页面加载时初始化
        document.addEventListener('DOMContentLoaded', initializePage);
    </script>
</body>
</html> 